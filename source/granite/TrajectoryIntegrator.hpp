#pragma once

#define PY_ARRAY_UNIQUE_SYMBOL MAGSENSE_ARRAY_API
#define NO_IMPORT_ARRAY

#include <algorithm>
#include <iostream>
#include <mutex>
#include <thread>
#include <tuple>
#include <unordered_map>
#include <utility>

#include <pybind11/numpy.h>
#include <pybind11/pybind11.h>

#include <cmath>
#include <cuda.h>

#include "granite/AbortReason.hpp"
#include "granite/Constants.hpp"
#include "granite/DataLoader.hpp"
#include "granite/Info.hpp"
#include "granite/IntegratorSettings.hpp"
#include "granite/SimulationData.hpp"
#include "granite/TextureInfo.hpp"
#include "granite/TrajectorySet.hpp"

// generated by python script
#include "granite/TrajectoryIntegratorKernelSelection.hpp"

#define MY_USE_CUDA_TYPES
#include "my/cuda/ToolKernel.cuh"
#include "my/math/Arithmetic.hpp"
#include "my/math/Constants.hpp"
#include "my/math/LinearAlgebra.hpp"
#include "my/util/SwapChain.hpp"
#include "my/util/Util.cuh"

#define PYGRANITE_KERNEL_TEMPLATE_ARGS                                                             \
    template <typename VEC_T,                                       /**/                           \
              granite::Space SPACE,                                 /**/                           \
              granite::Integrator INTEGRATOR,                       /**/                           \
              granite::BorderMode BORDER_MODE,                      /**/                           \
              granite::CurvatureMode CURVATURE_MODE,                /**/                           \
              granite::AbortMode ABORT_MODE,                        /**/                           \
              granite::UpLiftMode UPLIFT_MODE,                      /**/                           \
              granite::WindfieldMode WINDFIELD_MODE,                /**/                           \
              granite::ConstantsMode CONSTANTS_MODE,                /**/                           \
              granite::AdditionalVolumeMode ADDITIONAL_VOLUME_MODE, /**/                           \
              bool USE_TOPOGRAPHY,                                  /**/                           \
              bool USE_REVERSE_COMPUTATION,                         /**/                           \
              bool USE_SPHERE_COORDINATES,                          /**/                           \
              bool COMP_ADDITIONAL,                                 /**/                           \
              bool COMP_ADDITIONAL_VOLUME>

#define PYGRANITE_KERNEL_TEMPLATE_CALL                                                             \
    VEC_T,                       /**/                                                              \
        SPACE,                   /**/                                                              \
        INTEGRATOR,              /**/                                                              \
        BORDER_MODE,             /**/                                                              \
        CURVATURE_MODE,          /**/                                                              \
        ABORT_MODE,              /**/                                                              \
        UPLIFT_MODE,             /**/                                                              \
        WINDFIELD_MODE,          /**/                                                              \
        CONSTANTS_MODE,          /**/                                                              \
        ADDITIONAL_VOLUME_MODE,  /**/                                                              \
        USE_TOPOGRAPHY,          /**/                                                              \
        USE_REVERSE_COMPUTATION, /**/                                                              \
        USE_SPHERE_COORDINATES,  /**/                                                              \
        COMP_ADDITIONAL,         /**/                                                              \
        COMP_ADDITIONAL_VOLUME

namespace granite
{

/**
 * @brief Class handling the trajectory computation process. Can be configured using @ref
 *        IntegratorSettings.
 *
 * @author Ronja Schnur (ronjaschnur@uni-mainz.de)
 */
class TrajectoryIntegrator
{
    // data
private:
    bool _dimensions_loaded{false};

protected:
    GridInfo _grid;
    IntegratorSettings _settings;

private:
    DataLoader & _loader;
    std::unique_ptr<TrajectorySet> _set{nullptr};

    // cpu side buffer of the start points (one for each possible dimension)
    // selection is dynamic to maintain a single Integrator class in python
    std::vector<my::math::Vec3> _start_particles_3d;
    std::vector<my::math::Vec2> _start_particles_2d;

    // 3 textures: one front, on back, one cache for async loading
    // current used texture indices
    size_t _back_index{0}, _front_index{1}, _cache_index{2};

    TextureInfo _windfield_textures[3][3]; // chain then dim
    TextureInfo _additional_textures[3][MAX_ADDITIONAL_VOLUMES];

    float * _uplift_device[3]{nullptr, nullptr, nullptr};
    float * _constants_device[3][MAX_CONSTANT_ADDITIONAL_COMPUTE]{nullptr, nullptr, nullptr,
                                                                  nullptr};

    TextureInfo _topography_texture;
    size_t _num_additional_constants{0};
    size_t _num_additional_volumes{0};

    // determines current integration step (required for saveinterval)
    size_t _simulation_counter{0};

    // The points operate in a swap chain on the device
    my::util::SwapChain<float *> _particles_device;

    std::unordered_map<std::string, ASTNodeType> _env;
    std::vector<std::string> _keys;

    // properties
protected:
    /**
     * @brief Initializes the object provided by the given set (only needed when the protected
     *        constructor was used)
     *
     * @param set
     */
    void initSet(TrajectorySet & set);

public:
    // ! has to stay in header !
    TrajectoryIntegrator(              //
        IntegratorSettings & settings, //
        DataLoader & loader,           //
        TrajectorySet & set            //
    ) : _loader{loader}
    {
        initSet(set);
        initializeData();
        initializeTopography();
    }

    ~TrajectoryIntegrator();

    // methods
public:
    /**
     * @brief Triggers the computation process. The implementation of this method is generated
     *        using a python script.
     *        Exposed to python.
     *
     * @return TrajectorySet with the computed values.
     */
    std::unique_ptr<granite::TrajectorySet> compute();

private:
    std::unique_ptr<granite::TrajectorySet> compute2D();
    std::unique_ptr<granite::TrajectorySet> compute3D();

    void verifySettings(); // todo

    void updateData(size_t index);

    /**
     * @brief Does an initial selection and buffers first windfields to the gpu.
     */
    void initializeData();

    /**
     * @brief Loads the provided python numpy array into a gpu texture (index) (3D)
     */
    void loadTexture3D(size_t texture_index, const std::vector<pybind11::array_t<float>> & data);

    /**
     * @brief Loads the provided python numpy array into a gpu texture (obj) (3D)
     */
    void loadTexture3D(cudaTextureObject_t & tex_obj, //
                       cudaArray_t & array,           //
                       bool & initialized,            //
                       const pybind11::array_t<float> & data);

    /**
     * @brief Loads the provided python numpy array into a gpu texture (index) (2D)
     */
    void loadTexture2D(size_t texture_index, const std::vector<pybind11::array_t<float>> & data);

    /**
     * @brief Loads the provided python numpy array into a gpu texture (obj) (2D)
     */
    void loadTexture2D(cudaTextureObject_t & tex_obj,         //
                       float *& device_buffer,                //
                       size_t & pitch,                        //
                       bool & initialized,                    //
                       const pybind11::array_t<float> & data, //
                       bool load_dimension);

    // initializes compute resources and runs the main loop
    PYGRANITE_KERNEL_TEMPLATE_ARGS
    void compute_(std::vector<std::vector<VEC_T>> & traj);

    // runs the main loop
    PYGRANITE_KERNEL_TEMPLATE_ARGS
    void computeLoop_(SimulationData<VEC_T> & data);

    // runs the loop on the gpu
    PYGRANITE_KERNEL_TEMPLATE_ARGS
    void computeLoopGPU_(SimulationData<VEC_T> & data,
                         const std::function<bool(void)> & alive, //
                         const float MAX_WINDFIELD_TIME,          //
                         const size_t COUNTER,                    //
                         const unsigned int BLOCKS,               //
                         const unsigned int THREADS);

    // Copies a line of trajectory points into the dataset (3D).
    void copyParticlePositions(const size_t NUM_POINTS, my::math::Vec3 * device_points);

    // Copies a line of trajectory points into the dataset (2D).
    void copyParticlePositions(const size_t NUM_POINTS, my::math::Vec2 * device_points);

    // Copies all data (including particle positon and curvature) to the dataset.
    template <typename VEC_T, granite::CurvatureMode CURVATURE_MODE, bool COMP_ADDITIONAL,
              bool COMP_ADDITIONAL_VOLUME>
    void copyParticleInfo(const SimulationData<VEC_T> & data);

    // Initializes the topography texture, if available.
    void initializeTopography();

    // generates identifier environment for provided settings
    std::unordered_map<std::string, ASTNodeType> generateEnvironment();

    PYGRANITE_KERNEL_SELECTION()
};

/**
 * @brief  Calculates whether a particle is out of the domain in 3D case (BorderMode::Block)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    bool
    out_of_box(const SimulationData<my::math::Vec3> & data, const my::math::Vec3 & v);

/**
 * @brief  Calculates whether a particle is out of the domain in 2D case (BorderMode::Block)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    bool
    out_of_box(const SimulationData<my::math::Vec2> & data, const my::math::Vec2 & v);

/**
 * @brief Linear interpolates between the texture value of arg at front and back using time as
 *        scalar. Overloaded version 3D.
 *
 * @param back   Back Texture
 * @param front  Front Texture
 * @param arg    Texture argument
 * @param time   Scalar
 * @return The interpolated value.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    float
    lerp_timed(cudaTextureObject_t back, cudaTextureObject_t front, const my::math::Vec3 & arg,
               float time);

/**
 * @brief Linear interpolates between the texture value of arg at front and back using time as
 *        scalar. Overloaded version 2D.
 *
 * @param back   Back Texture
 * @param front  Front Texture
 * @param arg    Texture argument
 * @param time   Scalar
 * @return The interpolated value.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    float
    lerp_timed(cudaTextureObject_t back, cudaTextureObject_t front, const my::math::Vec2 & arg,
               float time);

/**
 * @brief Transforms argn into texture space.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    my::math::Vec3
    texture_arg(const SimulationData<my::math::Vec3> & data, const my::math::Vec3 & argn);

/**
 * @brief Transforms argn into texture space.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    my::math::Vec2
    texture_arg(const SimulationData<my::math::Vec2> & data, const my::math::Vec2 & argn);

/**
 * @brief Interpolates the value inside additional volume with volume_id.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    float
    interpolate_volume(const SimulationData<my::math::Vec3> & data, const size_t volume_id,
                       const my::math::Vec3 & arg);

/**
 * @brief Interpolates the value inside additional volume with volume_id.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    float
    interpolate_volume(const SimulationData<my::math::Vec2> & data, const size_t volume_id,
                       const my::math::Vec2 & arg);

/**
 * @brief Interpolates the windfield strength at the given world position and time. (3D)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    my::math::Vec3
    interpolate(const SimulationData<my::math::Vec3> & data, const my::math::Vec3 & argn,
                float time);

/**
 * @brief Interpolates the windfield strength at the given world position and time. (2D)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    my::math::Vec2
    interpolate(const SimulationData<my::math::Vec2> & data, const my::math::Vec2 & argn,
                float time);

/**
 * @brief Interpolates the windfield strength at the given world position. (3D)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    my::math::Vec3
    interpolate(const SimulationData<my::math::Vec3> & data, const my::math::Vec3 & argn);

/**
 * @brief Interpolates the windfield strength at the given world position. (2D)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    my::math::Vec2
    interpolate(const SimulationData<my::math::Vec2> & data, const my::math::Vec2 & argn);

/**
 * @brief Tests whether the particle is below the topography. (3D)
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    bool
    in_topography(const SimulationData<my::math::Vec3> & data, const my::math::Vec3 & v);

/**
 * @brief Returns false, excists only for template purposes.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    bool
    in_topography(const SimulationData<my::math::Vec2> & data, const my::math::Vec2 & v);

/**
 * @brief Computes border handling for BorderMode::LoopX
 */
template <bool USE_SPHERE_COORDINATES>
#ifdef __NVCC__
__device__
#endif
    inline bool
    out_of_box_x(const SimulationData<my::math::Vec3> & data, my::math::Vec3 & v);

/**
 * @brief Computes border handling for BorderMode::LoopX
 */
template <bool USE_SPHERE_COORDINATES>
#ifdef __NVCC__
__device__
#endif
    inline bool
    out_of_box_x(const SimulationData<my::math::Vec2> & data, my::math::Vec2 & v);

/**
 * @brief Does nothing.
 */
template <bool USE_SPHERE_COORDINATES>
#ifdef __NVCC__
__device__
#endif
    inline bool
    out_of_box_y(const SimulationData<my::math::Vec3> & data, my::math::Vec3 & v);

/**
 * @brief Computes border handling for BorderMode::LoopY
 */
template <bool USE_SPHERE_COORDINATES>
#ifdef __NVCC__
__device__
#endif
    inline bool
    out_of_box_y(const SimulationData<my::math::Vec2> & data, my::math::Vec2 & v);

/**
 * @brief Does nothing.
 */
template <bool USE_SPHERE_COORDINATES>
#ifdef __NVCC__
__device__
#endif
    inline bool
    out_of_box_xy(const SimulationData<my::math::Vec3> & data, const my::math::Vec3 &,
                  my::math::Vec3 &);

/**
 * @brief Computes border handling for BorderMode::LoopXY
 */
template <bool USE_SPHERE_COORDINATES>
#ifdef __NVCC__
__device__
#endif
    inline bool
    out_of_box_xy(const SimulationData<my::math::Vec2> & data, const my::math::Vec2 & o,
                  my::math::Vec2 & n);

#ifdef __NVCC__
__device__
#endif
float
interpolate_volume(const SimulationData<my::math::Vec2> & data,
                            const cudaTextureObject_t & back, const cudaTextureObject_t & front,
                            const my::math::Vec2 & argn, float time);

#ifdef __NVCC__
__device__
#endif
float
interpolate_volume(const SimulationData<my::math::Vec3> & data,
                            const cudaTextureObject_t & back, const cudaTextureObject_t & front,
                            const my::math::Vec3 & argn, float time);


/**
 * @brief Transforms given radial speeds into change of latitude and longitude per second.
 */
template <typename VEC_T>
#ifdef __NVCC__
__device__ __forceinline__
#endif
    VEC_T
    sphere_coordinates(SimulationData<VEC_T> & data, float py, VEC_T & v);

/**
 * @brief Computes the discrete curvature for a given point using previous and following positions.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    float
    kappa(const my::math::Vec3 & pm1, const my::math::Vec3 & p, const my::math::Vec3 & pp1,
          float DT);

/**
 * Returns 0.f as it is not definied in a 2D case.
 */
#ifdef __NVCC__
__device__ __forceinline__
#endif
    float
    kappa(const my::math::Vec2 & pm1, const my::math::Vec2 & p, const my::math::Vec2 & pp1,
          float DT);

// The integration kernel, highly templated to reduce code duplication.
PYGRANITE_KERNEL_TEMPLATE_ARGS
#ifdef __NVCC__
__global__
#endif
    void
    integrate(SimulationData<VEC_T> data);

/**
 * @brief Interprets the AST into the provided output stream.
 */
std::ostream & operator<<(std::ostream & os, const std::shared_ptr<ASTTNode> & node);

/**
 * @brief Flattens the AST into a ASTANode array (for easier access on gpu)
 */

std::vector<ASTANode> flatten(const std::shared_ptr<granite::ASTTNode> & node);

std::shared_ptr<granite::ASTTNode>
replace_environment(std::shared_ptr<granite::ASTTNode> node,
                    const std::unordered_map<std::string, ASTNodeType> & env);

void _print(const ASTANode * nodes, const size_t num_nodes, const size_t i = 0);

/**
 * @brief prints a flattened ast array (gpu + cpu)
 */

void print(const ASTANode * nodes, const size_t num_nodes);

std::shared_ptr<ASTTNode> parse(const std::string & code);

/**
 * @brief Interprets the AST using the provided reference values
 */
float interpret(const std::shared_ptr<ASTTNode> & node, const float * ref);

bool contains(const std::shared_ptr<ASTTNode> & node, ASTNodeType t);

/**
 * @brief Interprets a flattened AST array (gpu + cpu)
 */
// only templated to allow compilation in multiple files reducing ram overhead
PYGRANITE_KERNEL_TEMPLATE_ARGS
#ifdef __NVCC__
__device__ __host__
#endif
    float // ! has to stay in header for testing
    interpret(const ASTANode * nodes, const size_t num_nodes, const float * ref, const size_t i)
{
    if (i >= num_nodes) return 0.f;

    auto node{nodes[i]};
    switch (node.Type)
    {
        case ASTNodeType::Reference_X: return ref[0];
        case ASTNodeType::Reference_Y: return ref[1];
        case ASTNodeType::Reference_Z: return ref[2];
        case ASTNodeType::Reference_CV: return ref[3];
        case ASTNodeType::Reference_F0: return ref[4];
        case ASTNodeType::Reference_F1: return ref[5];
        case ASTNodeType::Reference_F2: return ref[6];
        case ASTNodeType::Reference_F3: return ref[7];
        case ASTNodeType::Reference_F4: return ref[8];
        case ASTNodeType::Reference_F5: return ref[9];
        case ASTNodeType::Reference_F6: return ref[10];
        case ASTNodeType::Reference_F7: return ref[11];
        case ASTNodeType::Reference_C0: return ref[12];
        case ASTNodeType::Reference_C1: return ref[13];
        case ASTNodeType::Reference_C2: return ref[14];
        case ASTNodeType::Reference_C3: return ref[15];
        case ASTNodeType::Reference_U: return ref[16];
        case ASTNodeType::Reference_V: return ref[17];
        case ASTNodeType::Reference_W: return ref[18];
        case ASTNodeType::Constant: return node.Value;
        case ASTNodeType::Addition:
            return interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left) +
                   interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Right);
        case ASTNodeType::Multiplication:
            return interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left) *
                   interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Right);
        case ASTNodeType::Substraction:
            return interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left) -
                   interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Right);
        case ASTNodeType::Division: {
            return interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left) /
                   interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Right);
        }
        case ASTNodeType::Operation_SQRT: {
            return sqrtf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_EXP: {
            return expf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_LN: {
            return logf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_SINE: {
            return sinf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_COSINE: {
            return cosf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_TANGENS: {
            return tanf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_ARCSINE: {
            return asinf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_ARCCOSINE: {
            return acosf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_ARCTANGENS: {
            return atanf(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left));
        }
        case ASTNodeType::Operation_ARCTANGENS_2: {
            return atan2f(
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Left),
                interpret<PYGRANITE_KERNEL_TEMPLATE_CALL>(nodes, num_nodes, ref, node.Right));
        }
        default: return 0.f;
    }
}

} // namespace granite

#include "granite/TrajectoryIntegrator.icc"
#include "granite/TrajectoryIntegrator.tpp"